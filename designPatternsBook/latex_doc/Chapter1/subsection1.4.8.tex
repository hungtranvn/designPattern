
\subsection{insert()} %subsection 1.4.8
\begin{methodinfo}
  {insert}
  {iterator insert ( iterator position, const T& x ); 
  void insert ( iterator position, size_type n, const T& x ); 
  template <class InputIterator> 
      void insert ( iterator position, InputIterator first, InputIterator last );}
  {\texttt{position} – the \texttt{position} in the container at which the insertion of an element 
  (or elements) is to be performed. For \texttt{deque} and \texttt{vector}, this is \texttt{RandomAccessIterator}, 
  while in the case of a \texttt{list}, \texttt{BidirectionalIterator} is used;
  
  \texttt{x} – the value to be inserted;

  \texttt{n} – the number of \texttt{x} values to be inserted;

  \texttt{first, last} – the \texttt{iterators} specifying the range of elements to be inserted into 
  the container. As usual, the range includes \texttt{first} and excludes \texttt{last}.}
  {The first version of this method returns an \texttt{iterator} to a newly inserted object 
  if the insertion is successful. Other versions do not return anything.}
  {The method \texttt{insert()} performs an insertion into a container. There are three variants of 
  this method, as stated in the signature section. Inserting an element into a container will cause 
  the container to grow. This leads to different consequences, depending on the type of collection:
  \begin{itemize}
    \item \texttt{vector} – when an increase in size causes it to reallocate (not enough capacity left) 
      all iterators, references and pointers will be invalidated;
    \item \texttt{deque} – all iterators will be invalidated, references also, unless insertion at the beginning 
      or end takes place;
    \item \texttt{list} – the iterators and references remain.
  \end{itemize}}
\end{methodinfo}

\textcolor{green}{File name: 1.4.8.cpp}
\lstinputlisting[language=C++]{Chapter1/codes/1.4.8.cpp}
