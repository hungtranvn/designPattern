\documentclass[13pt]{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{CambridgeUS}     % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{beaver} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{tikz-uml}
\tikzumlset{font=\footnotesize\ttfamily, class width=6ex}
\usepackage{hyperref}

\usepackage{listings}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myCustomCppStyle}{
  language=C++,
  numbers=left,
  stepnumber=1,
  numbersep=9pt,
  tabsize=2,
  showspaces=false,
  showstringspaces=false
}

\lstset{basicstyle=\tiny,style=myCustomCppStyle}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=1
}

\lstset{style=mystyle}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{tikz}
\usetikzlibrary{decorations.text}
\usetikzlibrary{shapes.geometric, arrows, positioning, calc, matrix}

\tikzset{
  basic box/.style={
    shape=rectangle, rounded corners, align=center,
    draw=#1, fill=#1!25},
  header node/.style={
    Minimum Width=header nodes,
    font=\strut\Large\ttfamily,
    text depth=+0pt,
    fill=white, draw},
  header/.style={%
    inner ysep=+1.5em,
    append after command={
      \pgfextra{\let\TikZlastnode\tikzlastnode}
      node [header node] (header-\TikZlastnode) at (\TikZlastnode.north) {#1}
      node [span=(\TikZlastnode)(header-\TikZlastnode)] at (fit bounding box) (h-\TikZlastnode) {}
    }
  },
  hv/.style={to path={-|(\tikztotarget)\tikztonodes}},
  vh/.style={to path={|-(\tikztotarget)\tikztonodes}},
  fat blue line/.style={ultra thick, blue}
}

\definecolor{mygray}{RGB}{208,208,208}
\definecolor{mymagenta}{RGB}{226,0,116}
\newcommand*{\mytextstyle}{\sffamily\Large\bfseries\color{black!85}}
\newcommand{\arcarrow}[3]{%
   % inner radius, middle radius, outer radius, start angle,
   % end angle, tip protusion angle, options, text
   \pgfmathsetmacro{\rin}{1.7}
   \pgfmathsetmacro{\rmid}{2.2}
   \pgfmathsetmacro{\rout}{2.7}
   \pgfmathsetmacro{\astart}{#1}
   \pgfmathsetmacro{\aend}{#2}
   \pgfmathsetmacro{\atip}{5}
   \fill[mygray, very thick] (\astart+\atip:\rin)
                         arc (\astart+\atip:\aend:\rin)
      -- (\aend-\atip:\rmid)
      -- (\aend:\rout)   arc (\aend:\astart+\atip:\rout)
      -- (\astart:\rmid) -- cycle;
   \path[
      decoration = {
         text along path,
         text = {|\mytextstyle|#3},
         text align = {align = center},
         raise = -1.0ex
      },
      decorate
   ](\astart+\atip:\rmid) arc (\astart+\atip:\aend+\atip:\rmid);
}
\title[Design Pattern]{Creational Design Pattern}
\author{Hung Tran}
\institute{Fpt software}
\date{\today}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Uncomment these lines for an automatically generated outline.
\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{Creational Pattern Overview}

\begin{frame}{Creational Pattern Overview}
	\begin{center}
	\textcolor{blue}{\textbf{Construction process of an object.}}
	\end{center}
	\begin{itemize}
		\setlength\itemsep{1em}
		\item \textbf{Singleton}: Ensure only one instance.
		\item \textbf{Factory Method}: Create instance without depending on its concrete type.
		\item \textbf{Object pool}: Reuse existing instances.
		\item \textbf{Abstract factory}: Create instances from a specific family.
		\item \textbf{Prototype}: Clone existing objects from a prototype.
		\item \textbf{Builder}: Construct a complex object step by step.
	\end{itemize}
\end{frame}

\section{Factory Method Pattern}

\begin{frame}{"new" operator problem}
\begin{columns}[T]
\begin{column}{.48\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
\lstinputlisting{./examples/newOperator/newOperator.cpp}
\end{column}
\begin{column}{.48\textwidth}
	\begin{itemize}
		\setlength\itemsep{1em}
		\item Need name of class
		\item Tightly coupled with the name
		\item Add new class, modify the existing code
		\item Compiler does not know which instance created at compile time or an instance has to be created at runtime?
	\end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{The Intent of Factory Method Design Pattern}
	\begin{center}
	\textcolor{blue}{\textbf{Define an interface for creating an object, but let subclasses which class to instantitate. Factory method lets class defer instantiation to subclasses.}}
	\end{center}
\end{frame}

\begin{frame}{How to Implement of Factory Method Design Pattern?}
	\begin{itemize}
		\setlength\itemsep{1em}
		\item Different ways to implement
		\item An overridable method is provide that returns an instance of a class
		\item This method can be overridden to return instance of a subclass
		\item Behave likes \textbf{constructor}
		\item However, the constructor always returns the same instance
		\item The factory method can returns any sub-type 
		\item The factory method also called \textbf{virtual constructor}
		\item C++ language does not allow virtual constructor
	\end{itemize}
\end{frame}

\begin{frame}{Structure of Factory Method Design Pattern}
	\begin{center}
	\begin{tikzpicture}
	\umlemptyclass[type=abstract,x=0,y=0]{Product}
	\umlemptyclass[x=0,y=-3]{ConcreteProduct}
	\umlinherit{ConcreteProduct}{Product}
	
	\umlclass[type=abstract,x=4,y=0]{Creator}{}{\umlvirt{FactoryMethod()} \\ AnOperation()}
	\umlclass[x=4,y=-3]{ConcreteCreator}{}{FactoryMethod()}
	\umlinherit{ConcreteCreator}{Creator}
	\umlimport[geometry = -|-, weight = 0.3]{ConcreteCreator}{ConcreteProduct}
	\umlnote[x=8, y=-1, width = 4.2cm]{Creator}{product = FactoryMethod()}
	\umlnote[x=8, y=-4, width = 3.5cm]{ConcreteCreator}{return new concrete product}
	\end{tikzpicture}	
	\end{center}
\end{frame}

\begin{frame}{Modify existing code problem}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Product.h
\lstinputlisting{./examples/basicImplementation/naiveBasic/Product.h}
ConcreteProduct.h
\lstinputlisting{./examples/basicImplementation/naiveBasic/ConcreteProduct.h}
ConcreteProduct.cpp
\lstinputlisting{./examples/basicImplementation/naiveBasic/ConcreteProduct.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Creator.h
\lstinputlisting{./examples/basicImplementation/naiveBasic/Creator.h}
Creator.cpp
\lstinputlisting{./examples/basicImplementation/naiveBasic/Creator.cpp}
main.cpp
\lstinputlisting{./examples/basicImplementation/naiveBasic/main.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{What if we add one more ConcreteProduct class?}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
ConcreteProduct1.h
\lstinputlisting{./examples/basicImplementation/naiveBasic/ConcreteProduct1.h}
ConcreteProduct1.cpp
\lstinputlisting{./examples/basicImplementation/naiveBasic/ConcreteProduct1.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Creator.cpp
\lstinputlisting{./examples/basicImplementation/naiveBasic/Creator.cpp}
\textcolor{red}{\textbf{Factory Method Design Pattern comes in handy}}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Basic Implementation}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Product.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/Product.h}
ConcreteProduct.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteProduct.h}
ConcreteProduct.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteProduct.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
ConcreteProduct1.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteProduct1.h}
ConcreteProduct1.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteProduct1.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Basic Implementation}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Creator.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/Creator.h}
Creator.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/Creator.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
ConcreteCreator.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteCreator.h}
ConcreteCreator.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteCreator.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Basic Implementation of Factory Method Pattern}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
ConcreteCreator1.h
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteCreator1.h}
ConcreteCreator1.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/ConcreteCreator1.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
main.cpp
\lstinputlisting{./examples/basicImplementation/factoryBasics/main.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Class Diagram Explaining}
\begin{center}
\begin{tikzpicture}
	\umlemptyclass[type=abstract,x=0,y=1]{Product}
	\umlemptyclass[x=-2,y=-2]{ConcreteProduct}
	\umlemptyclass[x=2,y=-2]{ConcreteProduct1}
	\umlinherit[geometry=-|]{ConcreteProduct}{Product}
	\umlinherit[geometry=-|]{ConcreteProduct1}{Product}
	
	\umlclass[type=abstract,x=5,y=0]{Creator}{}{\umlvirt{Create()} \\ AnOperation()}
	\umlclass[x=3,y=-4]{ConcreteCreator}{}{Create()}
	\umlclass[x=7,y=-4]{ConcreteCreator1}{}{Create()}
	\umlinherit[geometry=-|]{ConcreteCreator}{Creator}
	\umlinherit[geometry=-|]{ConcreteCreator1}{Creator}
	
	\umluniassoc[geometry=|-, color=green]{Creator}{Product}
	
	\umlimport[geometry = -|, weight = 0.5, color=blue]{ConcreteCreator}{ConcreteProduct}
	\umlimport[geometry = |-, weight = 0.5, color=red]{ConcreteCreator1}{ConcreteProduct1}
\end{tikzpicture}	
\end{center}
\end{frame}

\begin{frame}{Real World Example: Application Framework?}
	\textcolor{blue}{We want to create an framework}	
	\begin{itemize}
		\setlength\itemsep{1em}
		\item Managing different kinds of document.
		\item 
		\item multiple instances are not required.
	\end{itemize}
\end{frame}

\begin{frame}{Real World Example: Application Framework}
\begin{center}
\begin{tikzpicture}
	\umlemptyclass[type=abstract,x=0,y=0]{Document}
	\umlemptyclass[x=-2,y=-2]{Text}
	\umlemptyclass[x=2,y=-2]{Graphics}
	\umlinherit[geometry=-|]{Text}{Document}
	\umlinherit[geometry=-|]{Graphics}{Document}
	
	\umlclass[x=5,y=0]{Application}{}{}
	
	\umluniassoc[geometry=|-]{Application}{Document}
\end{tikzpicture}	
\end{center}
\end{frame}

\begin{frame}{App framework}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Document.h
\lstinputlisting{./examples/appFramework/appBasics/Document.h}
TextDocument.h
\lstinputlisting{./examples/appFramework/appBasics/TextDocument.h}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
TextDocument.cpp
\lstinputlisting{./examples/appFramework/appBasics/TextDocument.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{App framework}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
Application.h
\lstinputlisting{./examples/appFramework/appBasics/Application.h}
Application.cpp
\lstinputlisting{./examples/appFramework/appBasics/Application.cpp}
\end{column}

\begin{column}{.45\textwidth}
\lstset{basicstyle=\tiny,style=myCustomCppStyle}
main.cpp
\lstinputlisting{./examples/appFramework/appBasics/main.cpp}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{The above implementation Problem}
	\textcolor{blue}{If we want to manage with different doc?}	
	\begin{itemize}
		\setlength\itemsep{1em}
		\item Managing different kinds of document.
		\item 
		\item multiple instances are not required.
	\end{itemize}
\end{frame}

\begin{frame}{Pros and Cons}
\begin{columns}[T]
\begin{column}{.45\textwidth}
	\begin{center}
	\textcolor{blue}{\textbf{Pros}}
	\end{center}
	\begin{itemize}
		\setlength\itemsep{1em}
		\item Class itself control the instantiation process.
		\item Can allow multiple instances.
		\item Better than global variable.
		\item Can be subclassed.
	\end{itemize}
\end{column}
\begin{column}{.45\textwidth}
	\begin{center}
	\textcolor{blue}{\textbf{Cons}}
	\end{center}
		\begin{itemize}
		\setlength\itemsep{1em}
		\item Testing is difficult
		\item DCLP is defective
		\item Lazy destruction is complex
	\end{itemize}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Where to use?}
	\textcolor{blue}{When only one instance should be use because:}	
	\begin{itemize}
		\setlength\itemsep{1em}
		\item multiple instances cause data corruption.
		\item managing global state or shared state.
		\item multiple instances are not required.
	\end{itemize}
\end{frame}
\section{Factory Method}

\end{document}
